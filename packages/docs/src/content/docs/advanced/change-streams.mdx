---
title: Change Streams
description: Real-time job notifications using MongoDB Change Streams.
---

import { Aside } from '@astrojs/starlight/components';

MongoDB Change Streams provide real-time notifications when jobs are created or updated, eliminating polling latency for instant job processing.

## What Are Change Streams?

Change Streams allow applications to subscribe to real-time data changes in MongoDB collections. Instead of polling ("Are there new jobs?"), Monque receives push notifications ("A new job was just added!").

## How Monque Uses Change Streams

### Default Behavior

When you call `start()`, Monque:

1. **Opens a Change Stream** on the jobs collection
2. **Listens for events**: new job insertions and status changes
3. **Triggers immediate processing** when relevant changes occur
4. **Maintains polling as backup** in case Change Streams fail

```typescript
const monque = new Monque(db);
await monque.initialize();
monque.start();

// Behind the scenes:
// - Change stream opened
// - Polling interval set as backup (10s by default)
// - Ready to process jobs instantly
```

### Event Types Monitored

```typescript
// Monque watches for:
{
  $or: [
    { operationType: 'insert' },  // New jobs
    {
      operationType: 'update',
      'updateDescription.updatedFields.status': { $exists: true }
    }  // Status changes (e.g., retry → pending)
  ]
}
```

## Benefits of Change Streams

| Without Change Streams       | With Change Streams      |
| ---------------------------- | ------------------------ |
| Poll every 1000ms            | Instant notification     |
| Average latency: 500ms       | Average latency: ~50ms   |
| Wasted queries when idle     | Only queries when needed |
| Scales poorly with many jobs | Efficient at any scale   |

<Aside type="note">
  With Change Streams, job processing latency drops from an average of half the poll interval to near-instant. A job enqueued at time T is typically being processed within 50ms.
</Aside>

## Requirements

Change Streams require:

- **MongoDB 4.0+**
- **Replica Set or Sharded Cluster** (not standalone)

<Aside type="tip">
  MongoDB Atlas always runs as a replica set, so Change Streams work out of the box. For local development, use `--replSet rs0` when starting MongoDB.
</Aside>

### Local Development Setup

```bash
# Start MongoDB with replica set
docker run -d --name mongodb -p 27017:27017 mongo:7 --replSet rs0

# Initialize replica set
docker exec -it mongodb mongosh --eval "rs.initiate()"
```

## Event Lifecycle

### 1. Change Stream Connected

When Monque successfully opens a Change Stream:

```typescript
monque.on('changestream:connected', () => {
  console.log('✅ Change Stream connected - instant job notifications active');
});
```

### 2. Processing Events

When a job is inserted or becomes ready:

```typescript
// Internal flow:
// 1. Change Stream receives notification
// 2. Debounce timer (100ms) prevents claim storms
// 3. Worker attempts to claim job
// 4. Job is processed if claim succeeds
```

### 3. Error Handling

If the Change Stream encounters an error:

```typescript
monque.on('changestream:error', ({ error }) => {
  console.error('Change Stream error:', error.message);
  // Monque will attempt to reconnect
});
```

### 4. Fallback to Polling

After 3 failed reconnection attempts:

```typescript
monque.on('changestream:fallback', ({ reason }) => {
  console.warn('Falling back to polling:', reason);
  // System continues working, just with higher latency
});
```

### 5. Change Stream Closed

On graceful shutdown:

```typescript
monque.on('changestream:closed', () => {
  console.log('Change Stream closed');
});
```

## Configuration

### Poll Interval Adjustment

When Change Streams are active, polling serves as a backup:

```typescript
const monque = new Monque(db, {
  pollInterval: 10000  // 10s backup polling (default when Change Streams active)
});
```

<Aside type="note">
  Monque automatically adjusts the poll interval when Change Streams are working. The `pollInterval` option primarily affects backup polling frequency.
</Aside>

## Reconnection Strategy

Monque implements exponential backoff for reconnection:

```typescript
// Reconnection attempts:
// Attempt 1: Wait 1 second
// Attempt 2: Wait 2 seconds
// Attempt 3: Wait 4 seconds
// After 3 failures: Fall back to polling-only mode
```

## Monitoring Change Streams

### Health Check Integration

```typescript
// Change Stream status affects isHealthy()
if (monque.isHealthy()) {
  // Scheduler running and connected
  // (Change Stream may or may not be active)
}
```

### Detailed Monitoring

```typescript
// Track Change Stream state
let changeStreamActive = false;

monque.on('changestream:connected', () => {
  changeStreamActive = true;
  metrics.gauge('monque.changestream_active', 1);
});

monque.on('changestream:fallback', () => {
  changeStreamActive = false;
  metrics.gauge('monque.changestream_active', 0);
  alerting.warn('Monque Change Stream fell back to polling');
});

monque.on('changestream:closed', () => {
  changeStreamActive = false;
  metrics.gauge('monque.changestream_active', 0);
});
```

## Debouncing

To prevent "claim storms" when many jobs arrive simultaneously:

```typescript
// Internal behavior:
// - Multiple change events within 100ms are batched
// - Single claim attempt processes available jobs
// - Prevents overwhelming the database with concurrent claims
```

## Troubleshooting

### Change Stream Not Working

1. **Check MongoDB version**: Must be 4.0+
   ```bash
   mongosh --eval "db.version()"
   ```

2. **Verify replica set**: Change Streams require replica set
   ```bash
   mongosh --eval "rs.status()"
   ```

3. **Check events**: Listen for error events
   ```typescript
   monque.on('changestream:error', ({ error }) => {
     console.error('Change Stream error:', error);
   });
   ```

### High Latency Despite Change Streams

1. **Check if fallback occurred**: Listen for `changestream:fallback`
2. **Verify network latency**: High latency to MongoDB affects notifications
3. **Monitor debounce timing**: Very high job volume may show 100ms debounce delay

### Reconnection Loops

If you see repeated connection/disconnection:

```typescript
let reconnectCount = 0;

monque.on('changestream:connected', () => {
  reconnectCount = 0;
});

monque.on('changestream:error', () => {
  reconnectCount++;
  if (reconnectCount > 10) {
    console.error('Frequent Change Stream disconnections - check MongoDB stability');
  }
});
```

## Performance Comparison

### Test Setup

```typescript
// 1000 jobs enqueued, measured time to start processing

// Without Change Streams (polling at 1000ms):
// Average pickup latency: 487ms
// P95 pickup latency: 962ms

// With Change Streams:
// Average pickup latency: 23ms
// P95 pickup latency: 67ms
```

### Memory Usage

Change Streams add minimal memory overhead:

- One cursor per Monque instance
- Buffered events (typically < 1KB)
- No significant impact on heap

## Best Practices

### 1. Always Listen for Events

```typescript
monque.on('changestream:connected', () => {
  logger.info('Change Stream connected');
});

monque.on('changestream:fallback', ({ reason }) => {
  logger.warn('Change Stream fallback', { reason });
});

monque.on('changestream:error', ({ error }) => {
  logger.error('Change Stream error', { error: error.message });
});
```

### 2. Handle Graceful Degradation

```typescript
// Your application works whether Change Streams are active or not
// Just with different latency characteristics
```

### 3. Monitor Latency

```typescript
const enqueueTime = Date.now();

await monque.enqueue('measured-job', { enqueueTime });

monque.worker('measured-job', async (job) => {
  const pickupLatency = Date.now() - job.data.enqueueTime;
  metrics.histogram('monque.pickup_latency', pickupLatency);
});
```

## Next Steps

- [Atomic Claim Pattern](/advanced/atomic-claim/) - How job claiming works
- [Heartbeat Mechanism](/advanced/heartbeat/) - Detect stale jobs
