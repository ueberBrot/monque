---
title: Jobs
description: Understanding jobs and their lifecycle in Monque.
---

import { Aside } from '@astrojs/starlight/components';

Jobs are the fundamental unit of work in Monque. This guide explains how jobs work, their lifecycle, and how to work with them effectively.

## What is a Job?

A job represents a unit of work to be processed asynchronously. Each job has:

- **Name**: Identifies which worker should process it
- **Data**: The payload containing information needed to complete the work
- **Status**: Current state in the lifecycle (pending, processing, completed, failed)
- **Scheduling**: When the job should run (`nextRunAt`)

## Job Interface

For the full interface definition, see the [Job API Reference](/monque/api/interfaces/job/).

## Job Lifecycle

```mermaid
stateDiagram-v2
    [*] --> pending: enqueue()
    pending --> processing: worker claims
    processing --> completed: success
    processing --> pending: failure (retries left)
    processing --> failed: max retries exceeded
    completed --> pending: recurring job reschedules
```

### Status Definitions

| Status       | Description                                         |
| ------------ | --------------------------------------------------- |
| `pending`    | Job is waiting to be picked up by a worker          |
| `processing` | A worker has claimed and is executing the job       |
| `completed`  | Job finished successfully                           |
| `failed`     | Job permanently failed after exhausting all retries |

## Creating Jobs

### Immediate Execution

Use `now()` for jobs that should run immediately:

```typescript
const job = await monque.now('send-email', {
  to: 'user@example.com',
  subject: 'Hello!'
});

console.log(job._id); // ObjectId
console.log(job.status); // 'pending'
```

### Scheduled Execution

Use `enqueue()` with `runAt` for delayed execution:

```typescript
// Run in 1 hour
const job = await monque.enqueue('send-reminder', {
  userId: '123',
  message: 'Check back soon!'
}, {
  runAt: new Date(Date.now() + 3600000)
});
```

### Recurring Jobs

Use `schedule()` for cron-based recurring jobs:

```typescript
// Every day at midnight
const job = await monque.schedule('0 0 * * *', 'daily-report', {
  reportType: 'sales'
});
```

## Preventing Duplicates

Use `uniqueKey` to prevent duplicate jobs:

```typescript
// Only one sync job per user at a time
await monque.enqueue('sync-user', { userId: '123' }, {
  uniqueKey: 'sync-user-123'
});

// Attempting to enqueue again returns the existing job
const existing = await monque.enqueue('sync-user', { userId: '123' }, {
  uniqueKey: 'sync-user-123'
});
// existing._id === original job's _id
```

<Aside type="note">
  `uniqueKey` only prevents duplicates when a job with that key is in `pending` or `processing` status. Completed and failed jobs don't block new ones.
</Aside>

## Querying Jobs

### Get Jobs by Filter

```typescript
import { JobStatus } from '@monque/core';

// All pending email jobs
const pendingEmails = await monque.getJobs({
  name: 'send-email',
  status: JobStatus.PENDING
});

// All failed jobs (with pagination)
const failedJobs = await monque.getJobs({
  status: JobStatus.FAILED,
  limit: 50,
  skip: 0
});

// Multiple statuses
const activeJobs = await monque.getJobs({
  status: [JobStatus.PENDING, JobStatus.PROCESSING]
});
```

### Get Single Job by ID

```typescript
import { ObjectId } from 'mongodb';

const job = await monque.getJob(new ObjectId('...'));
if (job) {
  console.log(job.status, job.data);
}
```

## Job Data Best Practices

### Keep Payloads Small

Job data should be reference data, not full documents:

```typescript
// ✅ Good - Store ID, fetch data in worker
await monque.enqueue('process-order', { orderId: '123' });

// ❌ Bad - Large embedded data
await monque.enqueue('process-order', { 
  order: { /* entire order document */ }
});
```

### Use Type-Safe Payloads

Define interfaces for your job data:

```typescript
interface ProcessOrderJob {
  orderId: string;
  priority: 'urgent' | 'normal';
}

// Type-safe enqueue
await monque.enqueue<ProcessOrderJob>('process-order', {
  orderId: '123',
  priority: 'urgent'
});

// Type-safe worker
monque.worker<ProcessOrderJob>('process-order', async (job) => {
  const { orderId, priority } = job.data; // TypeScript knows the types
});
```

### Idempotent Operations

Design workers to handle duplicate execution safely:

<Aside type="note">
  Monque prevents two schedulers from claiming the same pending job at the same time, but a job may still run more than once (for example after a crash, a retry, or stale recovery). Design handlers to be safe to re-run.
</Aside>

```typescript
monque.worker('charge-payment', async (job) => {
  const { paymentId } = job.data;
  
  // Check if already processed
  const payment = await db.payments.findOne({ _id: paymentId });
  if (payment.status === 'charged') {
    return; // Already done, safe to skip
  }
  
  // Process payment
  await chargePayment(payment);
});
```

## Job Retention

Monque provides built-in job retention to automatically clean up completed and failed jobs. This prevents your database from growing indefinitely.

You can configure retention when initializing Monque:

```typescript
const monque = new Monque(db, {
  // ... other options
  jobRetention: {
    completed: 24 * 60 * 60 * 1000,    // Keep completed jobs for 24 hours
    failed: 7 * 24 * 60 * 60 * 1000,   // Keep failed jobs for 7 days
    interval: 60 * 60 * 1000           // Run cleanup every hour (default)
  }
});
```

<Aside type="note">
  If `jobRetention` is not configured, no automatic cleanup is performed.
</Aside>

## Indexes

Monque creates MongoDB indexes during `initialize()` to keep polling, claiming, deduplication, and recovery queries fast.

<Aside type="note">
  Your MongoDB user must have permission to create indexes. If index creation is restricted in production, create the required indexes ahead of time.
</Aside>

The indexes Monque creates are:

- `{ status: 1, nextRunAt: 1 }` for efficient polling (ready-to-run jobs)
- `{ name: 1, uniqueKey: 1 }` as a **partial unique** index for deduplication (only when `uniqueKey` exists and status is `pending`/`processing`)
- `{ name: 1, status: 1 }` for querying by job type and status
- `{ claimedBy: 1, status: 1 }` for ownership queries and heartbeat updates
- `{ lastHeartbeat: 1, status: 1 }` for heartbeat-based monitoring queries
- `{ status: 1, nextRunAt: 1, claimedBy: 1 }` for the atomic claim query
- `{ lockedAt: 1, lastHeartbeat: 1, status: 1 }` to support stale recovery queries

### Manual Cleanup

If you need more complex retention logic (e.g. keep important sales reports longer), you can implement a custom scheduled job:

```typescript
await monque.schedule('0 3 * * *', 'custom-cleanup', {});

monque.worker('custom-cleanup', async () => {
  // Use Monque's public API to query and manage jobs
  const oldJobs = await monque.getJobs({
    status: JobStatus.COMPLETED,
    // Add custom filter logic here
  });
  // Process cleanup based on your retention rules
});
```

## Next Steps

- [Workers](/monque/core-concepts/workers/) - Learn how to process jobs
- [Scheduling](/monque/core-concepts/scheduling/) - Deep dive into cron expressions
- [Retry & Backoff](/monque/core-concepts/retry/) - Configure retry behavior
